webpackJsonp([1],{"7xn4":function(e,n){},NHnr:function(e,n,t){"use strict";Object.defineProperty(n,"__esModule",{value:!0});var a=t("7+uW"),i={render:function(){var e=this.$createElement,n=this._self._c||e;return n("div",{attrs:{id:"app"}},[n("router-view")],1)},staticRenderFns:[]};var l=t("VU/8")({name:"App"},i,!1,function(e){t("7xn4")},null,null).exports,o=t("/ocq"),s=t("mvHQ"),r=t.n(s),c=t("Dd8w"),p=t.n(c),d=t("gRE1"),v=t.n(d),y=t("Gu7T"),m=t.n(y),u="javascript",g="plaintext",h="css",f=[{title:{type:g,val:"promise"},desc:[{type:u,val:"创建 promise 对象\n        new Promise()\n\n        Promise.resolve 和 Promise.reject\n        \n          //Promise.resolve(42) 相当于\n          new Promise(function(resolve){\n            resolve(42);\n          });\n      "},{type:g,val:"Promise.all\n        传递给 Promise.all 的promise并不是一个个的顺序执行的，而是同时开始、并行执行的\n      "},{type:g,val:"Promise.race\n        Promise.race 只要有一个promise对象进入 FulFilled 或者 Rejected 状态的话，就会继续进行后面的处理\n      "},{type:g,val:"reject\n        将promise对象的状态设置为Rejected的时候应该使用 reject 而不是 throw\n        因为我们很难区分 throw 是我们主动抛出来的，还是因为真正的其它 异常 导致的\n      "},{type:g,val:"then 返回值\n        不管是 then 还是 catch 方法调用，都返回了一个新的promise对象\n\n        如果then中的回调函数返回一个值，那么then返回的Promise将会成为接受状态，并且将返回的值作为接受状态的回调函数的参数值。\n        如果then中的回调函数抛出一个错误，那么then返回的Promise将会成为拒绝状态，并且将抛出的错误作为拒绝状态的回调函数的参数值。\n        如果then中的回调函数返回一个已经是接受状态的Promise，那么then返回的Promise也会成为接受状态，并且将那个Promise的接受状态的回调函数的参数值作为该被返回的Promise的接受状态回调函数的参数值。\n        如果then中的回调函数返回一个已经是拒绝状态的Promise，那么then返回的Promise也会成为拒绝状态，并且将那个Promise的拒绝状态的回调函数的参数值作为该被返回的Promise的拒绝状态回调函数的参数值。\n        如果then中的回调函数返回一个未定状态（pending）的Promise，那么then返回Promise的状态也是未定的，并且它的终态与那个Promise的终态相同；同时，它变为终态时调用的回调函数参数与那个Promise变为终态时的回调函数的参数是相同的。\n      "}]},{title:{type:g,val:"使用import时，webpack对node_modules里的依赖会做什么"},desc:[{type:g,val:"三种引入方式\n        相对路径 import {button} from '../component/button'\n        绝对路径 import {button} from '/home/me/file'\n        模块名 import React from 'react'\n        "},{type:g,val:"\n        默认的node_modules可以根据webpack配置的resolve.modules进行更改\n        查找中会根据webpack配置的resolve.extensions自动补全扩展名\n        查找中会根据wepack配置的resolve.alias替换掉别名"},{type:g,val:"\n        webpack解析代码路径的核心模块是enhanced-resolve模块\n        webpack解析匹配代码路径的配置在resolve里面"}]},{title:{type:g,val:"js 异步编程"},desc:[{type:g,val:"\n        callback\n        Promise\n        async/await"}]},{title:{type:g,val:"http 请求报文"},desc:[{type:g,val:"Request\n        请求行\n        头部\n        请求数据\n        "},{type:g,val:"Request\n        状态行\n        头部\n        响应正文\n        "}]},{title:{type:g,val:"cookie"},desc:[{type:g,val:"作用\n        对话（session）管理：保存登录、购物车等需要记录的信息。\n        个性化：保存用户的偏好，比如网页的字体大小、背景色等等。\n        追踪：记录和分析用户行为。"}]}],w=[{title:{type:g,val:"JS的基本数据类型和引用数据类型"},desc:[{type:g,val:"基本数据类型：undefined、null、boolean、number、string、symbol"},{type:g,val:"引用数据类型：object(array、function)"}]},{title:{type:g,val:"分析 ['1', '2', '3'].map(parseInt) 答案是多少？"},desc:[{type:g,val:"答案:[1, NaN, NaN]"},{type:g,val:"parseInt(string, radix) 第2个参数 radix 表示进制。省略 radix 或 radix = 0，则数字将以十进制解析"},{type:g,val:"map 每次为 parseInt 传3个参数(elem, index, array)，其中 index 为数组索引"}]},{title:{type:g,val:"水平垂直居中: 定位和需要定位的元素的margin减去宽高的一半"},desc:[{type:h,val:"\n        img{\n          width: 100px;\n          height: 150px;\n          position: absolute; \n          top: 50%; \n          left: 50%; \n          margin-top: -75px; \n          margin-left: -50px;\n        }\n      "}]},{title:{type:g,val:"水平垂直居中: 定位和margin:auto"},desc:[{type:h,val:"\n      img{\n        width: 100px;\n        height: 100px;\n        position: absolute;\n        top: 0;\n        left: 0;\n        right: 0;\n        bottom: 0;\n        margin: auto;\n    }\n      "}]},{title:{type:g,val:"水平垂直居中: 绝对定位和transfrom"},desc:[{type:h,val:"\n        img{\n          width: 100px;\n          height: 100px;\n          position: absolute;\n          top: 50%;\n          left: 50%;\n          transform: translate(-50%,-50%);\n      }\n      "}]},{title:{type:g,val:"水平垂直居中: flexBox居中"},desc:[{type:h,val:"\n        .box{\n          width: 300px;\n          height: 300px;\n          background:#e9dfc7; \n          border:1px solid red;\n          display: flex;\n          justify-content: center;\n          align-items:center;\n      }\n      img{\n          width: 150px;\n          height: 100px;\n      }\n      "}]},{title:{type:g,val:"确定包含块"},desc:[{type:g,val:"如果 position 属性为 static 或 relative ，包含块就是由它的最近的祖先块元素"},{type:g,val:"如果 position 属性为 absolute ，包含块就是由它的最近的 position 的值不是 static （也就是值为fixed, absolute, relative 或 sticky）的祖先元素的内边距区的边缘组成"},{type:g,val:"如果 position 属性是 fixed，包含块就是由 viewport "}]},{title:{type:g,val:"根据包含块计算百分值"},desc:[{type:g,val:"要计算 height top 及 bottom 中的百分值，是通过包含块的 height 的值"},{type:g,val:"要计算 width, left, right, padding, margin 这些属性由包含块的 width 属性的值来计算它的百分值"}]},{title:{type:g,val:"this"},desc:[{type:g,val:"\n      函数在全局被调用时：\n      this 就代表全局对象\n      "},{type:g,val:"\n      作为对象的方法被调用时：\n      this 就是这个上级对象\n      "},{type:g,val:"\n      作为构造函数调用时：\n      this 就是这个新对象\n      "},{type:g,val:"\n      apply 调用： \n      this 指的是 apply 的第一个参数\n      "}]},{title:{type:g,val:"{a:1}.a报错，错误Uncaught SyntaxError: Unexpected token ."},desc:[{type:u,val:"({a:1}.a) // 或({a:1}).a"},{type:g,val:"简单说，就是声明对象字面值时，语句开头不应该用{，因为js解释器会认为这是语句块（block）的开始。"}]},{title:{type:g,val:"123.toFixed(2)报错，错误Uncaught SyntaxError: Unexpected token ILLEGAL"},desc:[{type:u,val:'(123).toFixed(2) // >> "123.00"'},{type:g,val:"js解释器会把数字后的.当做小数点而不是点操作符"}]},{title:{type:u,val:"//parseInt传入数字时为什么有以下输出？\n    parseInt(0.000008) // >> 0\n    parseInt(0.0000008) // >> 8"},desc:[{type:g,val:"parseInt(arg)时会调用arg.toString()。"},{type:u,val:'(0.000008).toString() // "0.000008"\n      (0.0000008).toString() // "8e-7"'}]},{title:{type:g,val:"localStorage"},desc:[{type:u,val:"localStorage.setItem(`myCat`, `Tom`);"},{type:u,val:"let cat = localStorage.getItem(`myCat`);"},{type:u,val:"localStorage.removeItem(`myCat`);"},{type:u,val:"localStorage.clear();"}]},{title:{type:g,val:"cookie vs localStorage"},desc:[{type:g,val:"4k, \n        5M"},{type:g,val:"一般由服务器生成，可设置失效时间。如果在浏览器端生成Cookie，默认是关闭浏览器后失效, \n        除非被清除，否则永久保存"},{type:g,val:"每次都会携带在HTTP头中，如果使用cookie保存过多数据会带来性能问题\n        仅在客户端（即浏览器）中保存，不参与和服务器的通信"}]},{title:{type:g,val:"position"},desc:[{type:g,val:"static\n      该关键字指定元素使用正常的布局行为，即元素在文档常规流中当前的布局位置"},{type:g,val:"relative\n      该关键字下，元素先放置在未添加定位时的位置，再在不改变页面布局的前提下调整元素位置（因此会在此元素未添加定位时所在位置留下空白）。"},{type:g,val:"absolute\n      不为元素预留空间，通过指定元素相对于最近的非 static 定位祖先元素的偏移，来确定元素位置。"},{type:g,val:"fixed\n      不为元素预留空间，而是通过指定元素相对于屏幕视口（viewport）的位置来指定元素位置。"},{type:g,val:"sticky \n      盒位置根据正常流计算(这称为正常流动中的位置)，然后相对于该元素在流中的 flow root（BFC）和 containing block（最近的块级祖先元素）定位。"}]},{title:{type:g,val:"跨域的解决办法"},desc:[{type:u,val:"jsonp\n        let script = document.createElement('script')\n\n        script.src = 'http://www.xxx.cn/login?username=xxx&callback=callback'\n        \n        document.body.appendChild(script)\n        \n        function callback(res) {\n          console.log(res)\n        }"},{type:u,val:'document.domain + iframe\n\n        A页面:\n        <iframe \n        style = "display : none" \n        name = "iframe1" \n        id = "iframe" \n        src="http://b.nealyang.cn/1.html" frameborder="0"></iframe>\n        <script type="text/javascript">\n          $(function(){\n            try{\n              document.domain = "nealyang.cn"\n            }catch(e){}\n            $("#iframe").load(function(){\n              var jq = document.getElementById(\'iframe\').contentWindow.$\n              jq.get("http://nealyang.cn/test.json",function(data){\n                console.log(data)\n              })\n            })\n          })\n        <\/script>\n\n        B页面:\n        <head>\n          <meta charset="UTF-8">\n          <title>html</title>\n          <script type="text/javascript" src = "jquery-1.12.1.js"><\/script>\n          <script type="text/javascript">\n            $(function(){\n              try{\n                document.domain = "nealyang.com"\n              }catch(e){}\n            })\n          <\/script>\n        </head>\n        '},{type:u,val:"postMessage跨域\n\n        a.html: \n        <iframe id=\"iframe\" src=\"http://www.neal.cn/b.html\" style=\"display:none\"></iframe>\n        <script>       \n          var iframe = document.getElementById('iframe')\n          iframe.onload = function() {\n            var data = {\n              name: 'aym'\n            }\n            // 向neal传送跨域数据\n            iframe.contentWindow.postMessage(JSON.stringify(data), 'http://www.neal.cn')\n          }\n\n          // 接受domain2返回数据\n          window.addEventListener('message', function(e) {\n            alert('data from neal ---\x3e ' + e.data)\n          }, false)\n        <\/script>\n\n        b.html:\n        <script>\n          // 接收domain1的数据\n          window.addEventListener('message', function(e) {\n            alert('data from nealyang ---\x3e ' + e.data)\n\n            var data = JSON.parse(e.data)\n            if (data) {\n              data.number = 16\n\n              // 处理后再发回nealyang\n              window.parent.postMessage(JSON.stringify(data), 'http://www.nealyang.cn')\n            }\n          }, false)\n        <\/script>\n        "},{type:g,val:'\n          cors "跨域资源共享"（Cross-origin resource sharing）\n\n          简单请求 -> 1. head, get, post(post 的 content-type 为 application/x-www-form-urlencoded, multipart/form-data 或 text/plain)；2. 没有自定义请求头\n          - 浏览器会加上一个 header 叫 Origin \n          - 服务器需要设置 Access-Control-Allow-Origin 为 * 或者包含由 Origin 指明的站点\n\n          非简单请求 -> 1. put delete； 2. Content-Type字段的类型是application/json\n          - 先发送一个 OPTIONS 请求给目的站点，来查明这个跨站请求对于目的站点是不是安全可接受的\n          - 如果同意请求则响应中包含 Access-Control-Allow-Origin 并且内容包含当前站点地址；如果不同意则响应中不包含 cors 相关的 header\n            - Access-Control-Allow-Origin: http://foo.example //表明服务器允许http://foo.example的请求\n            - Access-Control-Allow-Methods: POST, GET, OPTIONS //表明服务器可以接受POST, GET和 OPTIONS的请求方法\n            - Access-Control-Allow-Headers: X-PINGOTHER //传递一个可接受的自定义请求头列表。服务器也需要设置一个与浏览器对应。否则会报 Request header field X-Requested-With is not allowed by Access-Control-Allow-Headers in preflight response 的错误\n            - Access-Control-Max-Age: 1728000 //告诉浏览器，本次“预请求”的响应结果有效时间是多久。在上面的例子里，1728000秒代表着20天内，浏览器在处理针对该服务器的跨站请求，都可以无需再发送“预请求”，只需根据本次结果进行判断处理。\n          - 预检之后，就和简单请求一样了（Origin/Access-Control-Allow-Origin）\n        '}]},{title:{type:g,val:"http 请求头"},desc:[{type:g,val:"Accept: text/plain"},{type:g,val:"Accept-Charset: utf-8"},{type:g,val:"Accept-Encoding: gzip, deflate"},{type:g,val:"Cache-Control: no-cache"},{type:g,val:"Cookie: $Version=1; Skin=new;"},{type:g,val:"Content-Length: 348"},{type:g,val:"Content-Type: application/x-www-form-urlencoded"},{type:g,val:"Origin: http://www.itbilu.com"},{type:g,val:"Referer: http://itbilu.com/nodejs"}]},{title:{type:g,val:"1px问题"},desc:[{type:g,val:"border-image"},{type:g,val:'根据 dpr 设置 initial-scale 及 rem\n        /* 设计稿是750,采用1：100的比例,font-size为100 * (docEl.clientWidth * dpr / 750) */\n        var dpr, rem, scale;\n        var docEl = document.documentElement;\n        var fontEl = document.createElement(‘style‘);\n        var metaEl = document.querySelector(‘meta[name="viewport"]‘);\n        dpr = window.devicePixelRatio || 1;\n        rem = 100 * (docEl.clientWidth * dpr / 750);\n        scale = 1 / dpr;\n        // 设置viewport，进行缩放，达到高清效果\n        metaEl.setAttribute(‘content‘, ‘width=‘ + dpr * docEl.clientWidth + ‘,initial-scale=‘ + scale + ‘,maximum-scale=‘ + scale + ‘, minimum-scale=‘ + scale + ‘,user-scalable=no‘);\n        // 设置data-dpr属性，留作的css hack之用，解决图片模糊问题和1px细线问题\n        docEl.setAttribute(‘data-dpr‘, dpr);\n        // 动态写入样式\n        docEl.firstElementChild.appendChild(fontEl);\n        fontEl.innerHTML = ‘html{font-size:‘ + rem + ‘px!important;}‘;\n      '},{type:g,val:"transform scale  (使用 @media 或者 js 查到 dpr 设置相应类名)\n          .transform-scale {\n            position: relative;\n            &:after,\n            &:before {\n                content: '';\n                position: absolute;\n                left: 0;\n                top: 0;\n                height: 1px;\n                width: 100%;\n                -webkit-transform: scaleY(0.5);\n                transform: scaleY(0.5);\n                -webkit-transform-origin: 0 0;\n                transform-origin: 0 0;\n                background: #f00;\n            }\n            &:after {\n                top: auto;\n                bottom: 0;\n                -webkit-transform-origin: 0 100%;\n                transform-origin: 0 100%;\n            }\n        }\n        "}]},{title:{type:g,val:"Flex 布局"},desc:[{type:g,val:"flex container, flex item"},{type:g,val:"\n        flex-direction\n        flex-wrap\n        flex-flow\n        justify-content\n        align-items\n        align-content\n      "},{type:g,val:"\n        order\n        flex-grow\n        flex-shrink\n        flex-basis\n        flex\n        align-self\n      "}]},{title:{type:g,val:"flex: 1;"},desc:[{type:g,val:"flex: 1 或者 flex: 2 等等。它相当于flex: 1 1 0。元素可以在flex-basis为0的基础上伸缩"}]},{title:{type:g,val:"absolute 居中"},desc:[{type:h,val:"\n        top:0; bottom:0; left:0; right:0; \n        position:absolute; \n        margin:auto; \n        height:something; \n        width:something;\n      "}]},{title:{type:g,val:"使用过webpack里面哪些plugin和loader"},desc:[{type:g,val:"\n          eslint-loader\n          vue-loader\n          babel-loader \n          url-loader 在文件大小（单位 byte）低于指定的限制时，可以返回一个 DataURL。\n          sass-loader\n        "},{type:g,val:"\n          DefinePlugin 允许创建一个在编译时可以配置的全局常量。\n          HotModuleReplacementPlugin 启用热替换模块(Hot Module Replacement)，也被称为 HMR。\n          CopyWebpackPlugin copy custom static assets\n          UglifyJsPlugin\n          ExtractTextPlugin 将所有的入口 chunk(entry chunks)中引用的 *.css，移动到独立分离的 CSS 文件\n          OptimizeCSSPlugin\n          HashedModuleIdsPlugin keep module.id stable when vendor modules does not change\n          CommonsChunkPlugin 建立一个独立文件(又称作 chunk)的功能，这个文件包括多个入口 chunk 的公共模块。通过将公共模块拆出来，最终合成的文件能够在最开始的时候加载一次，便存起来到缓存中供后续使用。\n        "}]},{title:{type:g,val:"编写一个 webpack plugin   class版"},desc:[{type:g,val:"\n          plugin 是一个 class ，其中有一个 apply 方法，会传入 compiler（webpack 的主环境） 对象，\n          compiler 会暴露一组钩子，提供对每个新的编译对象(compilation 一组新的编译资源)的引用。\n          反过来，编译对象(compilation)提供了额外的事件钩子函数，用于钩入到构建流程的很多步骤中\n        "},{type:u,val:"\n          class FileListPlugin {\n            apply(compiler) {\n              compiler.hooks.emit.tapAsync('FileListPlugin', (compilation, callback) => {\n                // 在生成文件中，创建一个头部字符串：\n                var filelist = 'In this build:\n\n';\n          \n                // 遍历所有编译过的资源文件，\n                // 对于每个文件名称，都添加一行内容。\n                for (var filename in compilation.assets) {\n                  filelist += ('- '+ filename +'\n');\n                }\n          \n                // 将这个列表作为一个新的文件资源，插入到 webpack 构建中：\n                compilation.assets['filelist.md'] = {\n                  source() {\n                    return filelist;\n                  },\n                  size() {\n                    return filelist.length;\n                  }\n                };\n          \n                callback();\n              });\n            }\n          }\n          \n          module.exports = FileListPlugin;\n        "}]},{title:{type:g,val:"编写一个 webpack plugin   prototype版"},desc:[{type:g,val:"\n          独立的 JS 模块，暴露相应的函数\n          函数原型上的 apply 方法会注入 compiler 对象\n          compiler 对象上挂载了相应的 webpack 事件钩子\n          事件钩子的回调函数里能拿到编译后的 compilation 对象，如果是异步钩子还能拿到相应的 callback\n        "},{type:u,val:"\n          function MyPlugin(options) {}\n          // 2.函数原型上的 apply 方法会注入 compiler 对象\n          MyPlugin.prototype.apply = function(compiler) {\n            // 3.compiler 对象上挂载了相应的 webpack 事件钩子 4.事件钩子的回调函数里能拿到编译后的 compilation 对象\n            compiler.plugin('emit', (compilation, callback) => {\n              ...\n            })\n          }\n          // 1.独立的 JS 模块，暴露相应的函数\n          module.exports = MyPlugin\n        "}]},{title:{type:g,val:"webpack dev server 怎么跑起来的"},desc:[{type:"json",val:'\n        "scripts": {\n          "dev": "webpack-dev-server --inline --progress --config build/webpack.dev.conf.js",\n          "start": "npm run dev",\n          "lint": "eslint --ext .js,.vue src",\n          "build": "node build/build.js"\n        },\n      '},{type:g,val:"不同于 webpack 打包，webpack_dev_server 输出的文件只存在于内存中"}]},{title:{type:g,val:"vue 项目优化"},desc:[{type:g,val:"template\n          v-show v-if 的使用场景\n          :key\n          style scpoed\n        "},{type:g,val:"\b生态\n          vue-router 组件懒加载\n        "},{type:g,val:"打包\n          UI 库按需要加载\n          异步组件\n        "}]},{title:{type:g,val:"js 对象的深拷贝"},desc:[{type:u,val:"不考虑对象中的函数、正则对象\n        function copy (obj) {\n          var newobj = obj.constructor === Array ? [] : {};\n          if(typeof obj !== 'object'){\n              return;\n          }\n          for(var i in obj){\n            newobj[i] = typeof obj[i] === 'object' ?\n            copy(obj[i]) : obj[i];\n          }\n          return newobj\n        }\n      "},{type:u,val:"JSON.parse(JSON.stringify(XXXX))"},{type:g,val:"ES6扩展运算符"},{type:u,val:"var copyObj = Object.assign({}, obj)"}]},{title:{type:g,val:"vue-router 实现路由切换"},desc:[{type:u,val:"Hash Mode:\n        改路由：\n          window.location.hash = path\n          window.location.replace(\n            window.location.href.slice(0, i >= 0 ? i : 0) + '#' + path\n          )\n        改视图：\n          Vue.mixin -> beforeCreate -> Vue.util.defineReactive(this, '_route', this._router.history.current);\n          当_route值改变时，会自动调用Vue实例的render()方法，更新视图\n\n        监听：window.addEventListener(\"hashchange\", funcRef, false);\n      "},{type:u,val:"History Mode:\n        改路由：\n          window.history.pushState(stateObject,title,url)\n          window.history,replaceState(stateObject,title,url)\n\n        监听：window.addEventListener('popstate', e => {\n      "}]},{title:{type:g,val:"webpack loader"},desc:[{type:g,val:"loader 能够让 webpack 处理那些非 JavaScript 文件，并且先将它们转换为有效 模块，然后添加到依赖图中，这样就可以提供给应用程序使用"},{type:g,val:"webpack.config.js -> module.rules -> test use"}]},{title:{type:g,val:"webpack plugin"},desc:[{type:g,val:"loader 被用于转换某些类型的模块，而插件则可以用于执行范围更广的任务，插件的范围包括：打包优化、资源管理和注入环境变量"},{type:g,val:"webpack.config.js -> plugins -> new 一个 plugin 实例"}]},{title:{type:g,val:"vuex 解决了什么问题"},desc:[{type:g,val:"\n        多个视图依赖于同一状态。\n        来自不同视图的行为需要变更同一状态。\n\n        对于问题一，传参的方法对于多层嵌套的组件将会非常繁琐，并且对于兄弟组件间的状态传递无能为力。\n        对于问题二，我们经常会采用父子组件直接引用或者通过事件来变更和同步状态的多份拷贝。以上的这些模式非常脆弱，通常会导致无法维护的代码。\n      "},{type:g,val:"采用集中式存储管理应用的所有组件的状态，并以相应的规则保证状态以一种可预测的方式发生变化"}]},{title:{type:g,val:"async 与 promise 区别"},desc:[{type:g,val:"\n        真正地用同步的方式写异步代码\n        不用写then及其回调函数，减少代码行数，也避免了代码嵌套\n        所有异步调用可以写在同一个代码块中，无需定义多余的中间变量\n        async函数会隐式地返回一个Promise，因此可以直接return变量，无需使用Promise.resolve进行转换\n      "}]},{title:{type:g,val:"debounce"},desc:[{type:u,val:"\n        function debounce(handle, delay) {\n          var timer = null\n          return function() {\n            var _this = this,\n                _arg = arguments\n            clearTimeout(timer)\n            timer = setTimeout(function() {\n              handle.apply(_this, _arg)\n            }, delay)\n          }\n        }\n      "}]},{title:{type:g,val:"http/2"},desc:[{type:g,val:"二进制分帧\n        在应用层与传输层之间增加一个二进制分帧层\n        在二进制分帧层上，HTTP2.0会将所有传输的信息分割为更小的消息和帧,并对它们采用二进制格式的编码，其中HTTP1.x的首部信息会被封装到Headers帧，而我们的request body则封装到Data帧里面\n      "},{type:g,val:"压缩头部\n        HTTP/2.0规定了在客户端和服务器端会使用并且维护「首部表」来跟踪和存储之前发送的键值对，对于相同的头部，不必再通过请求发送，只需发送一次\n      "},{type:g,val:"多路复用\n        客户端和服务器可以把HTTP 消息分解为互不依赖的帧，然后乱序发送，最后再在另一端把它们重新组合起来。注意，同一链接上有多个不同方向的数据流在传输。客户端可以一边乱序发送stream，也可以一边接收者服务器的响应，而服务器那端同理\n      "},{type:g,val:"请求优先级\n        既然所有资源都是并行发送，那么就需要「优先级」的概念了，这样就可以对重要的文件进行先传输，加速页面的渲染。\n      "},{type:g,val:"强制 SSL\n        虽然 HTTP/2.0 协议并没声明一定要用 SSL，但是 Google Chrome 等浏览器强制要求使用 HTTP/2.0 必须要用上 SSL， 也就是说必须要： https://\n      "},{type:g,val:"服务器推送\n        服务器可以对一个客户端请求发送多个响应\n      "}]},{title:{type:g,val:"在 HTTP/1.1 时代主要增加了"},desc:[{type:g,val:"keep-alive 选项，建立连接后，在一定时间内不会断开，其他请求都可以使用这条连接"},{type:g,val:"pipelining 管道，通过这个管道，浏览器的多个请求可以同时发到服务器，但是服务器的响应只能够一个接着一个的返回 ( 但各大浏览器有些不支持/默认关闭,因此这功能可以说是鸡肋)"}]},{title:{type:g,val:"Service Worker"},desc:[{type:u,val:"注册\n        if (navigator.serviceWorker) {  \n          navigator.serviceWorker.register('/sw.js')\n            .then(registration => {\n              console.log('恭喜。作用范围: ', registration.scope);\n            })\n            .catch(error => {\n              console.log('抱歉', error);\n            });\n        }\n        // 浏览器会找到 /sw.js 文件，然后保存在当前被访问的域名的名下。该文件包含各类事件的处理逻辑，整体定义你的Service Worker的行为\n      "},{type:u,val:"install 事件；在安装阶段缓存资源\n          const CACHE_NAME = 'cache-v1';  \n          const urlsToCache = [  \n            '/',\n            '/js/main.js',\n            '/css/style.css',\n            '/img/bob-ross.jpg',\n          ];\n\n          self.addEventListener('install', event => {  \n            caches.open(CACHE_NAME)\n              .then(cache => {\n                return cache.addAll(urlsToCache);\n              });\n          });\n        "},{type:u,val:"fetch 事件\n          self.addEventListener('fetch', event => {  \n            const { request } = event;\n            const findResponsePromise = caches.open(CACHE_NAME)\n              .then(cache => cache.match(request))\n              .then(response => {\n                if (response) {\n                  return response;\n                }\n          \n                return fetch(request);\n              });\n          \n            event.respondWith(findResponsePromise);\n          });\n        "},{type:u,val:"activate 事件\n          当实际的网页关掉并重新打开时，浏览器会将原先的Service Worker替换成新的，然后在 install 事件之后触发 activate 事件。如果你需要清理缓存或者针对原来的SW执行维护性操作，activate 事件就是做这些事情的绝佳时机\n        "},{type:u,val:"sync 事件\n          // app.js\n          navigator.serviceWorker.ready  \n            .then(registration => {\n              document.getElementById('submit').addEventListener('click', () => {\n                registration.sync.register('submit').then(() => {\n                  console.log('sync registered!');\n                });\n              });\n            });\n\n          // sw.js\n          self.addEventListener('sync', event => {  \n            if (event.tag === 'submit') {\n              console.log('sync!');\n            }\n          });\n        "},{type:u,val:"消息推送\n          // app.js\n          // ask for permission\n          Notification.requestPermission(permission => {  \n            console.log('permission:', permission);\n          });\n          \n          // display notification\n          function displayNotification() {  \n            if (Notification.permission == 'granted') {\n              navigator.serviceWorker.getRegistration()\n                .then(registration => {\n                  registration.showNotification('this is a notification!');\n                });\n            }\n          }\n\n          // sw.js\n          self.addEventListener('notificationclick', event => {  \n            // 消息提醒被点击的事件\n          });\n\n          self.addEventListener('notificationclose', event => {  \n            // 消息提醒被关闭的事件\n          });\n        "}]},{title:{type:g,val:"并发请求"},desc:[{type:u,val:"\n          axios\n            .all([axios.get('/profile'), axios.post('/user')])\n            .then(axios.spread((res1, res2)=>{\n              console.log(res1)\n              console.log(res2)\n            }))\n        "}]},{title:{type:g,val:"浏览器事件"},desc:[{type:g,val:"\n        捕获阶段\n        目标阶段，在目标上绑定了了捕获及冒泡的事件方法时，先绑定的先发生\n        冒泡阶段\n        "},{type:g,val:"onclick直接绑定的事件发生在了冒泡阶段"},{type:g,val:"target是真正发生事件的DOM元素，而currentTarget是当前事件发生在哪个DOM元素上"},{type:g,val:"e.preventDefault()\n        可以阻止事件的默认行为发生，默认行为是指：点击a标签就转跳到其他页面、拖拽一个图片到浏览器会自动打开、点击表单的提交按钮会提交表单等等"},{type:g,val:"e.stopPropagation()\n        不仅可以阻止事件在冒泡阶段的传播，还能阻止事件在捕获阶段的传播"}]}],b=[].concat(m()(w),m()(f)),x={name:"MyDesc",props:{val:{type:Array,default:function(){return[]}}}},k={render:function(){var e=this,n=e.$createElement,t=e._self._c||n;return t("div",{staticClass:"desc_container"},[t("ul",{staticClass:"desc"},e._l(e.val,function(n){return t("li",{key:n.val,staticClass:"desc_item"},[t("pre",{directives:[{name:"highlightjs",rawName:"v-highlightjs"}]},[t("code",{class:n.type},[e._v(e._s(n.val))])])])}))])},staticRenderFns:[]};var j=t("VU/8")(x,k,!1,function(e){t("NM2J")},"data-v-59a1df10",null).exports,P=t("/Fbx"),S=t.n(P),C={name:"Home",components:{MyDesc:j},data:function(){return{title:{},desc:"",questionIndex:"",grade:0,gradeLength:6,gradeVals:[],stage:{}}},computed:{stageLength:function(){return this.gradeVals.length},titleType:function(){return this.title.type},titleVal:function(){return this.title.val}},created:function(){console.log("TCL: created -> questions.length",b.length),this.getQuestion(),this.initStatus()},methods:{initStatus:function(){var e=this.getGradeStore();this.gradeVals=v()(e),this.stage=S()(this.gradeVals)},getRandomInt:function(e,n){return Math.floor(Math.random()*(n-e))+e},getGradeStore:function(){return JSON.parse(window.localStorage.getItem("grade_store"))||{}},getIndexArr:function(){var e=this.getGradeStore();console.log("TCL: getIndexArr -> gradeStore",e);var n=b.map(function(e,n){return n});for(var t in e)for(var a=e[t],i=0;i<a;i++)n.push(parseInt(t));return console.log("TCL: getIndexArr -> indexArr",n),n},getQuestion:function(){var e=this,n=this.getGradeStore(),t=this.getIndexArr(),a=this.getRandomInt(0,t.length);this.questionIndex=t[a];var i=b.find(function(n,t){return t===e.questionIndex});console.log("TCL: getQuestion -> question",i),this.title=p()({},i.title),this.desc=i.desc,this.grade=n[this.questionIndex]},clickGrade:function(e){console.log(e);var n=this.getGradeStore()||{};n[this.questionIndex]=e,window.localStorage.setItem("grade_store",r()(n)),this.getQuestion(),this.initStatus()}}},E={render:function(){var e=this,n=e.$createElement,t=e._self._c||n;return t("div",{staticClass:"home_container"},[t("div",{staticClass:"status"},[t("div",{staticClass:"bar"},e._l(e.gradeLength,function(n){return t("div",{staticClass:"grade_stage",class:"stage_"+(n-1),style:{width:(e.stage[n-1]||0)/e.stageLength*100+"%"}})}))]),t("div",{staticClass:"title"},[t("pre",{directives:[{name:"highlightjs",rawName:"v-highlightjs"}],key:e.titleVal},[t("code",{class:e.titleType},[e._v(e._s(e.titleVal))])])]),t("my-desc",{attrs:{val:e.desc}}),t("div",{staticClass:"grade"},e._l(e.gradeLength,function(n){return t("div",{staticClass:"grade_item",class:{active:e.grade===n-1},on:{click:function(t){e.clickGrade(n-1)}}},[e._v(e._s(n-1))])}))],1)},staticRenderFns:[]};var A=t("VU/8")(C,E,!1,function(e){t("a50n")},"data-v-6617e971",null).exports;a.a.use(o.a);var T=new o.a({routes:[{path:"/",name:"Home",component:A}]}),_=t("V8mf"),I=t.n(_);a.a.directive("highlightjs",{deep:!0,bind:function(e,n){e.querySelectorAll("code").forEach(function(e){n.value&&(e.textContent=n.value),I.a.highlightBlock(e)})},componentUpdated:function(e,n){e.querySelectorAll("code").forEach(function(e){n.value&&(e.textContent=n.value,I.a.highlightBlock(e))})}}),a.a.config.productionTip=!1,new a.a({el:"#app",router:T,components:{App:l},template:"<App/>"})},NM2J:function(e,n){},a50n:function(e,n){}},["NHnr"]);
//# sourceMappingURL=app.20a4e4e1b62366e0228b.js.map